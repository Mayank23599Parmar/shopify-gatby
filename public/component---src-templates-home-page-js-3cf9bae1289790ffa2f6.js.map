{"version":3,"file":"component---src-templates-home-page-js-3cf9bae1289790ffa2f6.js","mappings":"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","sources":["webpack://my-gatsby-site/./src/components/global/Navbar.jsx","webpack://my-gatsby-site/./src/components/global/Footer.jsx","webpack://my-gatsby-site/./src/components/global/Layout.jsx","webpack://my-gatsby-site/./src/components/home/HomeBanner.jsx","webpack://my-gatsby-site/./src/components/home/HomeCategory.jsx","webpack://my-gatsby-site/./src/components/home/HomeNewAraival.jsx","webpack://my-gatsby-site/./node_modules/graphql/jsutils/invariant.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/location.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/printLocation.mjs","webpack://my-gatsby-site/./node_modules/graphql/error/GraphQLError.mjs","webpack://my-gatsby-site/./node_modules/graphql/jsutils/isObjectLike.mjs","webpack://my-gatsby-site/./node_modules/graphql/error/syntaxError.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/directiveLocation.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/tokenKind.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/lexer.mjs","webpack://my-gatsby-site/./node_modules/graphql/language/parser.mjs","webpack://my-gatsby-site/./node_modules/graphql-tag/lib/index.js","webpack://my-gatsby-site/./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js","webpack://my-gatsby-site/./node_modules/@apollo/client/react/parser/index.js","webpack://my-gatsby-site/./node_modules/@apollo/client/react/hooks/useQuery.js","webpack://my-gatsby-site/./node_modules/@apollo/client/react/hooks/useApolloClient.js","webpack://my-gatsby-site/./src/components/home/HomeBlogs.jsx","webpack://my-gatsby-site/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js","webpack://my-gatsby-site/./src/templates/homePage.js"],"sourcesContent":["import { Link} from 'gatsby'\n//import { StaticImage } from 'gatsby-plugin-image';\nimport React from 'react'\n\nexport default function Navbar() {\n  return (\n    <header className=\"py-4 shadow-sm bg-white\">\n        <div className=\"container flex items-center justify-between\">\n            <Link to='/'>\n            Logo\n            </Link>\n\n            <div className=\"w-full max-w-xl relative flex\">\n                <span className=\"absolute left-4 top-3 text-lg text-gray-400\">\n                    <i className=\"fa-solid fa-magnifying-glass\"></i>\n                </span>\n                <input type=\"text\" name=\"search\" id=\"search\"\n                    className=\"w-full border border-primary border-r-0 pl-12 py-3 pr-3 rounded-l-md focus:outline-none\"\n                    placeholder=\"search\"/>\n                <button\n                    className=\"bg-primary border border-primary text-white px-8 rounded-r-md hover:bg-transparent hover:text-primary transition\">Search</button>\n            </div>\n\n            <div className=\"flex items-center space-x-4\">\n            <Link to='/' className=\"text-center text-gray-700 hover:text-primary transition relative\">\n                    <div className=\"text-2xl\">\n                        <i className=\"fa-regular fa-heart\"></i>\n                    </div>\n                    <div className=\"text-xs leading-3\">Wishlist</div>\n                    <div\n                        className=\"absolute right-0 -top-1 w-5 h-5 rounded-full flex items-center justify-center bg-primary text-white text-xs\">\n                        8</div>\n                </Link>\n                <Link to='/' className=\"text-center text-gray-700 hover:text-primary transition relative\">\n                    <div className=\"text-2xl\">\n                        <i className=\"fa-solid fa-bag-shopping\"></i>\n                    </div>\n                    <div className=\"text-xs leading-3\">Cart</div>\n                    <div\n                        className=\"absolute -right-3 -top-1 w-5 h-5 rounded-full flex items-center justify-center bg-primary text-white text-xs\">\n                        2</div>\n                </Link>\n                <Link to='/' className=\"text-center text-gray-700 hover:text-primary transition relative\">\n                    <div className=\"text-2xl\">\n                        <i className=\"fa-regular fa-user\"></i>\n                    </div>\n                    <div className=\"text-xs leading-3\">Account</div>\n                </Link>\n            </div>\n        </div>\n    </header>\n  )\n}\n ","import { Link } from 'gatsby'\nimport React from 'react'\n\nexport default function Footer() {\n  return (\n<footer className=\"bg-white rounded-lg shadow m-4 dark:bg-gray-800\">\n    <div className=\"w-full mx-auto max-w-screen-xl p-4 md:flex md:items-center md:justify-between\">\n      <span className=\"text-sm text-gray-500 sm:text-center dark:text-gray-400\">© 2023 <Link to=\"/\" className=\"hover:underline\">Flowbite™</Link>. All Rights Reserved.\n    </span>\n    <ul className=\"flex flex-wrap items-center mt-3 text-sm font-medium text-gray-500 dark:text-gray-400 sm:mt-0\">\n        <li>\n            <Link to=\"/\" activeClassName=\"active\" className=\"mr-4 hover:underline md:mr-6 \">Home</Link>\n        </li>\n        <li>\n            <Link to=\"/products\" activeClassName=\"active\" className=\"mr-4 hover:underline md:mr-6\">Product</Link>\n        </li>\n        <li>\n            <Link to=\"/about\" activeClassName=\"active\" className=\"mr-4 hover:underline md:mr-6\">About</Link>\n        </li>\n    </ul>\n    </div>\n</footer>\n\n  )\n}\n","import React from \"react\";\nimport Navbar from \"./Navbar\";\nimport Footer from \"./Footer\";\nexport default function Layout({children,pageName=\"index\"}) {\n  return (\n    <div className={`template-${pageName}`}>\n      <Navbar />\n      <main id=\"mainContent\">\n        {children}\n      </main>\n      <Footer />\n    </div>\n  );\n}\n","import { Link } from 'gatsby'\nimport { GatsbyImage, getImage } from 'gatsby-plugin-image'\nimport React from 'react'\n\nexport default function HomeBanner({homeBanner}) {\n   const {title,descriptionHtml,handle,image}=homeBanner\n   const imageData = getImage(image)\n  return (\n    <section\n    className=\"relative \">\n        <GatsbyImage image={imageData} className='py-11' alt='home Banner'/>\n    <div className=\"container absolute top-1/2 -translate-y-1/2 left-10\">\n        <h1 className=\"text-6xl text-gray-800 font-medium mb-4 capitalize w-[600px]\">\n           {title}\n        </h1>\n        <div dangerouslySetInnerHTML={{__html: descriptionHtml}}></div>\n        <div className=\"mt-12\">\n            <Link to={`/collections/${handle}`} className=\"bg-primary border border-primary text-white px-8 py-3 font-medium \n                rounded-md hover:bg-transparent hover:text-primary\">Shop Now</Link>\n        </div>\n    </div>\n</section>\n  )\n}\n","import { Link } from 'gatsby'\nimport { GatsbyImage, getImage } from 'gatsby-plugin-image'\nimport React from 'react'\n\nexport default function HomeCategory({homeCategory}) {\n    const {nodes}=homeCategory\n  return (\n    <div className=\"container py-16\">\n    <h2 className=\"text-2xl font-medium text-gray-800 uppercase mb-6\">shop by category</h2>\n    <div className=\"grid grid-cols-3 gap-3\">\n        {\n            nodes.map((cv,index)=>{\n                \n                const imageData = getImage(cv.image)\n                return  <div className=\"relative rounded-sm overflow-hidden group\" key={index}>\n                <GatsbyImage image={imageData} alt=\"category 1\" className=\"w-full\"/>\n                <Link to={`/collections/${cv.handle}`}\n                    className=\"absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center text-xl text-white font-roboto font-medium group-hover:bg-opacity-60 transition\">{cv.title}\n                    </Link>\n            </div>\n            })\n        }\n    </div>\n</div>\n  )\n}\n","import { Link } from 'gatsby'\nimport { GatsbyImage, getImage } from 'gatsby-plugin-image'\nimport React from 'react'\n\nexport default function HomeNewAraival({homeNewAraivals}) {\n    const {products}=homeNewAraivals;\n    console.log(products,'products')\n  return (\n    <div className=\"container pb-16\">\n    <h2 className=\"text-2xl font-medium text-gray-800 uppercase mb-6\">top new arrival</h2>\n    <div className=\"grid grid-cols-1 md:grid-cols-4 gap-6\">\n{\n     products.map((product,index)=>{\n      const imageData=getImage(product.featuredImage?.gatsbyImageData)\n        return   <div className=\"bg-white shadow rounded overflow-hidden group flex justify-between flex-col\" key={index}>\n        <div className=\"relative\">\n            <GatsbyImage image={imageData} alt=\"product 1\" className=\"w-full\"/>\n            <div className=\"absolute inset-0 bg-black bg-opacity-40 flex items-center \n            justify-center gap-2 opacity-0 group-hover:opacity-100 transition\">\n                <Link to={``}\n                    className=\"text-white text-lg w-9 h-8 rounded-full bg-primary flex items-center justify-center hover:bg-gray-800 transition\"\n                    title=\"view product\">\n                    <i className=\"fa-solid fa-magnifying-glass\"></i>\n                </Link>\n                <Link to={``}\n                    className=\"text-white text-lg w-9 h-8 rounded-full bg-primary flex items-center justify-center hover:bg-gray-800 transition\"\n                    title=\"add to wishlist\">\n                    <i className=\"fa-solid fa-heart\"></i>\n                </Link>\n            </div>\n        </div>\n        <div className=\"pt-4 pb-3 px-4\">\n            <Link to={``}>\n                <h4 className=\"uppercase font-medium text-xl mb-2 text-gray-800 hover:text-primary transition\">{product.title}</h4>\n            </Link>\n            <div className=\"flex items-baseline mb-1 space-x-2\">\n                <p className=\"text-xl text-primary font-semibold\">$45.00</p>\n                <p className=\"text-sm text-gray-400 line-through\">$55.90</p>\n            </div>\n            <div className=\"flex items-center\">\n                <div className=\"flex gap-1 text-sm text-yellow-400\">\n                    <span><i className=\"fa-solid fa-star\"></i></span>\n                    <span><i className=\"fa-solid fa-star\"></i></span>\n                    <span><i className=\"fa-solid fa-star\"></i></span>\n                    <span><i className=\"fa-solid fa-star\"></i></span>\n                    <span><i className=\"fa-solid fa-star\"></i></span>\n                </div>\n                <div className=\"text-xs text-gray-500 ml-3\">(150)</div>\n            </div>\n        </div>\n        <Link to={``}\n            className=\"block w-full py-1 text-center text-white bg-primary border border-primary rounded-b hover:bg-transparent hover:text-primary transition\">Add\n            to cart</Link>\n    </div>\n    })\n}\n     \n        \n    </div>\n</div>\n  )\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, {\n    source,\n    positions: [position],\n  });\n}\n","/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation;\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n\nexport { DirectiveLocation };\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind;\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n\nexport { TokenKind };\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from 'react';\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false;\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey];\nexport var useSyncExternalStore = realHook || (function (subscribe, getSnapshot, getServerSnapshot) {\n    var value = getSnapshot();\n    if (__DEV__ &&\n        !didWarnUncachedGetSnapshot &&\n        value !== getSnapshot()) {\n        didWarnUncachedGetSnapshot = true;\n        __DEV__ && invariant.error('The result of getSnapshot should be cached to avoid an infinite loop');\n    }\n    var _a = React.useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _a[0].inst, forceUpdate = _a[1];\n    if (canUseLayoutEffect) {\n        React.useLayoutEffect(function () {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        }, [subscribe, value, getSnapshot]);\n    }\n    else {\n        Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n    }\n    React.useEffect(function () {\n        if (checkIfSnapshotChanged(inst)) {\n            forceUpdate({ inst: inst });\n        }\n        return subscribe(function handleStoreChange() {\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        });\n    }, [subscribe]);\n    return value;\n});\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nexport var DocumentType;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\nvar cache = new Map();\nexport function operationName(type) {\n    var name;\n    switch (type) {\n        case DocumentType.Query:\n            name = 'Query';\n            break;\n        case DocumentType.Mutation:\n            name = 'Mutation';\n            break;\n        case DocumentType.Subscription:\n            name = 'Subscription';\n            break;\n    }\n    return name;\n}\nexport function parser(document) {\n    var cached = cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n    __DEV__ ? invariant(!!document && !!document.kind, \"Argument of \".concat(document, \" passed to parser was not a valid GraphQL \") +\n        \"DocumentNode. You may need to use 'graphql-tag' or another method \" +\n        \"to convert your operation into a document\") : invariant(!!document && !!document.kind, 33);\n    var fragments = [];\n    var queries = [];\n    var mutations = [];\n    var subscriptions = [];\n    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {\n        var x = _a[_i];\n        if (x.kind === 'FragmentDefinition') {\n            fragments.push(x);\n            continue;\n        }\n        if (x.kind === 'OperationDefinition') {\n            switch (x.operation) {\n                case 'query':\n                    queries.push(x);\n                    break;\n                case 'mutation':\n                    mutations.push(x);\n                    break;\n                case 'subscription':\n                    subscriptions.push(x);\n                    break;\n            }\n        }\n    }\n    __DEV__ ? invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), \"Passing only a fragment to 'graphql' is not yet supported. \" +\n        \"You must include a query, subscription or mutation as well\") : invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), 34);\n    __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" +\n        \"\".concat(document, \" had \").concat(queries.length, \" queries, \").concat(subscriptions.length, \" \") +\n        \"subscriptions and \".concat(mutations.length, \" mutations. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 35);\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = DocumentType.Subscription;\n    var definitions = queries.length\n        ? queries\n        : mutations.length\n            ? mutations\n            : subscriptions;\n    __DEV__ ? invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \".concat(document, \" had \") +\n        \"\".concat(definitions.length, \" definitions. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(definitions.length === 1, 36);\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === 'Name') {\n        name = definition.name.value;\n    }\n    else {\n        name = 'data';\n    }\n    var payload = { name: name, type: type, variables: variables };\n    cache.set(document, payload);\n    return payload;\n}\nexport function verifyDocumentType(document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    __DEV__ ? invariant(operation.type === type, \"Running a \".concat(requiredOperationName, \" requires a graphql \") +\n        \"\".concat(requiredOperationName, \", but a \").concat(usedOperationName, \" was used instead.\")) : invariant(operation.type === type, 37);\n}\n//# sourceMappingURL=index.js.map","import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useCallback, useContext, useMemo, useRef, useState, } from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus, } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n    var stateRef = useRef();\n    if (!stateRef.current ||\n        client !== stateRef.current.client ||\n        query !== stateRef.current.query) {\n        stateRef.current = new InternalState(client, query, stateRef.current);\n    }\n    var state = stateRef.current;\n    var _a = useState(0), _tick = _a[0], setTick = _a[1];\n    state.forceUpdate = function () {\n        setTick(function (tick) { return tick + 1; });\n    };\n    return state;\n}\nvar InternalState = (function () {\n    function InternalState(client, query, previous) {\n        this.client = client;\n        this.query = query;\n        this.ssrDisabledResult = maybeDeepFreeze({\n            loading: true,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.loading,\n        });\n        this.skipStandbyResult = maybeDeepFreeze({\n            loading: false,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.ready,\n        });\n        this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n        verifyDocumentType(query, DocumentType.Query);\n        var previousResult = previous && previous.result;\n        var previousData = previousResult && previousResult.data;\n        if (previousData) {\n            this.previousData = previousData;\n        }\n    }\n    InternalState.prototype.forceUpdate = function () {\n        __DEV__ && invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n    };\n    InternalState.prototype.executeQuery = function (options) {\n        var _this = this;\n        var _a;\n        if (options.query) {\n            Object.assign(this, { query: options.query });\n        }\n        this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n        var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n        this.forceUpdate();\n        return new Promise(function (resolve) {\n            var result;\n            concast.subscribe({\n                next: function (value) {\n                    result = value;\n                },\n                error: function () {\n                    resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n                },\n                complete: function () {\n                    resolve(_this.toQueryResult(result));\n                }\n            });\n        });\n    };\n    InternalState.prototype.useQuery = function (options) {\n        var _this = this;\n        this.renderPromises = useContext(getApolloContext()).renderPromises;\n        this.useOptions(options);\n        var obsQuery = this.useObservableQuery();\n        var result = useSyncExternalStore(useCallback(function () {\n            if (_this.renderPromises) {\n                return function () { };\n            }\n            var onNext = function () {\n                var previousResult = _this.result;\n                var result = obsQuery.getCurrentResult();\n                if (previousResult &&\n                    previousResult.loading === result.loading &&\n                    previousResult.networkStatus === result.networkStatus &&\n                    equal(previousResult.data, result.data)) {\n                    return;\n                }\n                _this.setResult(result);\n            };\n            var onError = function (error) {\n                var last = obsQuery[\"last\"];\n                subscription.unsubscribe();\n                try {\n                    obsQuery.resetLastResults();\n                    subscription = obsQuery.subscribe(onNext, onError);\n                }\n                finally {\n                    obsQuery[\"last\"] = last;\n                }\n                if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n                    throw error;\n                }\n                var previousResult = _this.result;\n                if (!previousResult ||\n                    (previousResult && previousResult.loading) ||\n                    !equal(error, previousResult.error)) {\n                    _this.setResult({\n                        data: (previousResult && previousResult.data),\n                        error: error,\n                        loading: false,\n                        networkStatus: NetworkStatus.error,\n                    });\n                }\n            };\n            var subscription = obsQuery.subscribe(onNext, onError);\n            return function () { return setTimeout(function () { return subscription.unsubscribe(); }); };\n        }, [\n            obsQuery,\n            this.renderPromises,\n            this.client.disableNetworkFetches,\n        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });\n        this.unsafeHandlePartialRefetch(result);\n        return this.toQueryResult(result);\n    };\n    InternalState.prototype.useOptions = function (options) {\n        var _a;\n        var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n        var currentWatchQueryOptions = this.watchQueryOptions;\n        if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n            this.watchQueryOptions = watchQueryOptions;\n            if (currentWatchQueryOptions && this.observable) {\n                this.observable.reobserve(this.getObsQueryOptions());\n                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n                this.result = void 0;\n            }\n        }\n        this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n        this.onError = options.onError || InternalState.prototype.onError;\n        if ((this.renderPromises || this.client.disableNetworkFetches) &&\n            this.queryHookOptions.ssr === false &&\n            !this.queryHookOptions.skip) {\n            this.result = this.ssrDisabledResult;\n        }\n        else if (this.queryHookOptions.skip ||\n            this.watchQueryOptions.fetchPolicy === 'standby') {\n            this.result = this.skipStandbyResult;\n        }\n        else if (this.result === this.ssrDisabledResult ||\n            this.result === this.skipStandbyResult) {\n            this.result = void 0;\n        }\n    };\n    InternalState.prototype.getObsQueryOptions = function () {\n        var toMerge = [];\n        var globalDefaults = this.client.defaultOptions.watchQuery;\n        if (globalDefaults)\n            toMerge.push(globalDefaults);\n        if (this.queryHookOptions.defaultOptions) {\n            toMerge.push(this.queryHookOptions.defaultOptions);\n        }\n        toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n        return toMerge.reduce(mergeOptions);\n    };\n    InternalState.prototype.createWatchQueryOptions = function (_a) {\n        var _b;\n        if (_a === void 0) { _a = {}; }\n        var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\n        if (this.renderPromises &&\n            (watchQueryOptions.fetchPolicy === 'network-only' ||\n                watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n            watchQueryOptions.fetchPolicy = 'cache-first';\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n            Object.assign(watchQueryOptions, {\n                initialFetchPolicy: initialFetchPolicy,\n                fetchPolicy: 'standby',\n            });\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||\n                    this.getDefaultFetchPolicy();\n        }\n        return watchQueryOptions;\n    };\n    InternalState.prototype.getDefaultFetchPolicy = function () {\n        var _a, _b;\n        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\n            \"cache-first\");\n    };\n    InternalState.prototype.onCompleted = function (data) { };\n    InternalState.prototype.onError = function (error) { };\n    InternalState.prototype.useObservableQuery = function () {\n        var obsQuery = this.observable =\n            this.renderPromises\n                && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n                || this.observable\n                || this.client.watchQuery(this.getObsQueryOptions());\n        this.obsQueryFields = useMemo(function () { return ({\n            refetch: obsQuery.refetch.bind(obsQuery),\n            reobserve: obsQuery.reobserve.bind(obsQuery),\n            fetchMore: obsQuery.fetchMore.bind(obsQuery),\n            updateQuery: obsQuery.updateQuery.bind(obsQuery),\n            startPolling: obsQuery.startPolling.bind(obsQuery),\n            stopPolling: obsQuery.stopPolling.bind(obsQuery),\n            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n        }); }, [obsQuery]);\n        var ssrAllowed = !(this.queryHookOptions.ssr === false ||\n            this.queryHookOptions.skip);\n        if (this.renderPromises && ssrAllowed) {\n            this.renderPromises.registerSSRObservable(obsQuery);\n            if (obsQuery.getCurrentResult().loading) {\n                this.renderPromises.addObservableQueryPromise(obsQuery);\n            }\n        }\n        return obsQuery;\n    };\n    InternalState.prototype.setResult = function (nextResult) {\n        var previousResult = this.result;\n        if (previousResult && previousResult.data) {\n            this.previousData = previousResult.data;\n        }\n        this.result = nextResult;\n        this.forceUpdate();\n        this.handleErrorOrCompleted(nextResult);\n    };\n    InternalState.prototype.handleErrorOrCompleted = function (result) {\n        var _this = this;\n        if (!result.loading) {\n            var error_1 = this.toApolloError(result);\n            Promise.resolve().then(function () {\n                if (error_1) {\n                    _this.onError(error_1);\n                }\n                else if (result.data) {\n                    _this.onCompleted(result.data);\n                }\n            }).catch(function (error) {\n                __DEV__ && invariant.warn(error);\n            });\n        }\n    };\n    InternalState.prototype.toApolloError = function (result) {\n        return isNonEmptyArray(result.errors)\n            ? new ApolloError({ graphQLErrors: result.errors })\n            : result.error;\n    };\n    InternalState.prototype.getCurrentResult = function () {\n        if (!this.result) {\n            this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n        }\n        return this.result;\n    };\n    InternalState.prototype.toQueryResult = function (result) {\n        var queryResult = this.toQueryResultCache.get(result);\n        if (queryResult)\n            return queryResult;\n        var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n        this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));\n        if (!queryResult.error && isNonEmptyArray(result.errors)) {\n            queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n        }\n        return queryResult;\n    };\n    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n        if (result.partial &&\n            this.queryHookOptions.partialRefetch &&\n            !result.loading &&\n            (!result.data || Object.keys(result.data).length === 0) &&\n            this.observable.options.fetchPolicy !== 'cache-only') {\n            Object.assign(result, {\n                loading: true,\n                networkStatus: NetworkStatus.refetch,\n            });\n            this.observable.refetch();\n        }\n    };\n    return InternalState;\n}());\n//# sourceMappingURL=useQuery.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport { useContext } from 'react';\nimport { getApolloContext } from \"../context/index.js\";\nexport function useApolloClient(override) {\n    var context = useContext(getApolloContext());\n    var client = override || context.client;\n    __DEV__ ? invariant(!!client, 'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n        'instance in via options.') : invariant(!!client, 32);\n    return client;\n}\n//# sourceMappingURL=useApolloClient.js.map","\nimport React from 'react'\nimport { useQuery, gql } from '@apollo/client'\nconst COMMENTS_QUERY = gql`query{\n        blogs(first: 100) {\n          nodes {\n            handle\n            id\n            onlineStoreUrl\n            seo {\n              description\n              title\n            }\n            title\n            articles(first: 100) {\n              nodes {\n                handle\n                image {\n                  altText\n                  height\n                  id\n                  url\n                  width\n                }\n                title\n                excerptHtml\n                excerpt\n                content\n           contentHtml\n           publishedAt\n           authorV2 {\n            name\n          }\n              }\n            }\n          }\n        }\n      }`\nexport default function HomeBlogs({blogs}) {\n  const bdata = useQuery( COMMENTS_QUERY)\n  console.log(blogs,\"ddddddddddd\")\n  return (\n    <div className='test-test'>{\n      blogs.nodes?.map((blog,inex)=>{\n        return <h1 className='blogs-title-test'>{blog.title}</h1>\n      })\n    }</div>\n  )\n}\n","export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  strings.raw = raw;\n  return strings;\n}","import * as React from \"react\";\nimport Layout from \"../components/global/Layout\";\nimport { graphql } from \"gatsby\";\nimport HomeBanner from \"../components/home/HomeBanner\";\nimport HomeCategory from \"../components/home/HomeCategory\";\nimport HomeNewAraival from \"../components/home/HomeNewAraival\";\nimport HomeBlogs from \"../components/home/HomeBlogs\";\n\nconst homePage = ({data,pageContext}) => {\n  console.log(pageContext,\"dwdwed\")\n  // home banner data\n  const {homeBanner,homeCategory,homeNewAraivals}=data \n  const {blogs}=pageContext\n  return (\n    <Layout pageName=\"index\">\n      {/* home banner Data  */}\n      <HomeBanner homeBanner={homeBanner}/>\n      {/* home category sectionn */}\n      <HomeCategory homeCategory={homeCategory}/> \n      {/* home new araivals */}\n      <HomeNewAraival homeNewAraivals={homeNewAraivals}/>\n      {/* home blog section  */}\n      <HomeBlogs blogs={blogs}/>\n    </Layout>\n  ); \n};\n\nexport default homePage;\n\nexport const Head = () => <title>Home page</title>;\nexport const myQuery = graphql`\n  query SiteQuery {\n  homeBanner:shopifyCollection(handle: {eq: \"frontpage\"}) {\n    handle\n    description\n    descriptionHtml\n    image {\n      gatsbyImageData\n      altText\n      src\n    }\n    title\n  }\n  homeCategory:allShopifyCollection(limit: 10) {\n    nodes {\n      title\n      handle\n      image {\n        gatsbyImageData\n      }\n    }\n  }\n  homeNewAraivals:  shopifyCollection(handle: {eq: \"bundle\"}) {\n    products {\n      featuredImage {\n        altText\n        gatsbyImageData\n      }\n      description\n      handle\n      id\n      priceRange {\n        maxVariantPrice {\n          amount\n          currencyCode\n        }\n        minVariantPrice {\n          amount\n          currencyCode\n        }\n      }\n      productType\n      title\n      variants {\n        _product\n        availableForSale\n        barcode\n        id\n        image {\n          gatsbyImageData\n        }\n        price\n      }\n    }\n  }\n   markdownData: allMarkdownRemark {\n      nodes {\n        frontmatter {\n          slug\n          stack\n          title\n        }\n        id\n      }\n    }\n     site {\n      siteMetadata {\n        siteUrl\n        title\n        description\n      }\n    }\n    sitePlugin {\n      pluginOptions\n      pluginFilepath\n      ssrAPIs\n      resolve\n    }\n  }\n\n\n\n`;\n"],"names":["Navbar","className","to","type","name","id","placeholder","Footer","activeClassName","Layout","children","pageName","HomeBanner","homeBanner","title","descriptionHtml","handle","image","imageData","getImage","G","alt","dangerouslySetInnerHTML","__html","HomeCategory","homeCategory","nodes","map","cv","index","key","HomeNewAraival","homeNewAraivals","products","console","log","product","featuredImage","gatsbyImageData","invariant","condition","message","Boolean","Error","LineRegExp","getLocation","source","position","lastLineStart","line","match","body","matchAll","length","column","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","push","slice","printPrefixedLines","subLine","existingLines","filter","_","undefined","padLen","max","prefix","join","GraphQLError","constructor","rawArgs","_this$nodes","_nodeLocations$","_ref","positions","path","originalError","extensions","args","firstArg","toNormalizedOptions","super","this","undefinedIfEmpty","Array","isArray","nodeLocations","node","loc","start","locations","pos","originalExtensions","value","Object","create","defineProperties","writable","enumerable","stack","defineProperty","configurable","captureStackTrace","toStringTag","Symbol","toString","output","location","toJSON","formattedError","keys","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","SOF","lastToken","token","lineStart","advance","lookahead","kind","EOF","next","nextToken","readNextToken","end","prev","COMMENT","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","String","fromCodePoint","toUpperCase","createToken","col","bodyLength","readComment","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","readBlockString","readString","readNumber","readName","firstCode","isFloat","readDigits","FLOAT","INT","chunkStart","STRING","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","BLOCK_STRING","NAME","Parser","options","sourceObj","_lexer","_options","_tokenCounter","parseName","expectToken","parseDocument","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","parseVariableDefinition","VARIABLE_DEFINITION","variable","parseVariable","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","VARIABLE","SELECTION_SET","selections","parseSelection","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","parseList","parseObject","advanceLexer","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","OBJECT","fields","parseObjectField","OBJECT_FIELD","parseDirective","DIRECTIVE","innerType","LIST_TYPE","NON_NULL_TYPE","NAMED_TYPE","parseDescription","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","parseFieldDefinition","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","prototype","hasOwnProperty","call","startToken","noLocation","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","maxTokens","isPunctuatorTokenKind","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","get","has","warn","set","add","cacheKey","parsed","parse","doc","workSet","endToken","stripLoc","gql","literals","_i","result","arg","gql_1","extras","clear","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","didWarnUncachedGetSnapshot","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","__DEV__","error","_a","inst","forceUpdate","canUse","assign","checkIfSnapshotChanged","_b","DocumentType","cache","operationName","Query","Mutation","Subscription","verifyDocumentType","document","variables","cached","concat","fragments","queries","mutations","subscriptions","x","definition","payload","parser","requiredOperationName","usedOperationName","useQuery","query","client","stateRef","useRef","current","InternalState","state","useState","setTick","tick","useInternalState","override","context","useContext","previous","ssrDisabledResult","maybeDeepFreeze","loading","data","networkStatus","skipStandbyResult","ready","toQueryResultCache","WeakMap","previousResult","previousData","executeQuery","_this","watchQueryOptions","createWatchQueryOptions","queryHookOptions","concast","observable","reobserveAsConcast","getObsQueryOptions","Promise","resolve","toQueryResult","getCurrentResult","complete","renderPromises","useOptions","obsQuery","useObservableQuery","useCallback","onNext","setResult","onError","last","subscription","unsubscribe","resetLastResults","setTimeout","disableNetworkFetches","unsafeHandlePartialRefetch","currentWatchQueryOptions","reobserve","onCompleted","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","compact","reduce","mergeOptions","otherOptions","_c","getDefaultFetchPolicy","_d","initialFetchPolicy","getSSRObservable","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","error_1","toApolloError","then","catch","errors","graphQLErrors","queryResult","resultWithoutPartial","partial","called","partialRefetch","COMMENTS_QUERY","strings","raw","HomeBlogs","blogs","blog","inex","pageContext","Head"],"sourceRoot":""}